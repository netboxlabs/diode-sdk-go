package codegen

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/netboxlabs/diode-sdk-go/diode/v1/diodepb"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/runtime/protoimpl"
)

type assignableEntity struct {
	fieldName                string
	parentFieldName          string
	messageName              string
	nestedAssignableEntities map[string]assignableEntity
}

type methodParams struct {
	fieldName         string
	fieldType         string
	pointer           bool
	repeated          bool
	repeatedFieldType string
	messageField      bool
	nestedFieldName   string
	nestedMessageName string
}

// GenerateDiodeStructs generates diode structs based on the diodepb package
func GenerateDiodeStructs() {
	assignableEntityTypes := retrieveTypesAssignableToEntities((*diodepb.Entity)(nil).ProtoReflect(), "")

	protoTypes := []protoreflect.ProtoMessage{
		(*diodepb.Device)(nil),
		(*diodepb.DeviceType)(nil),
		(*diodepb.IPAddress)(nil),
		(*diodepb.Interface)(nil),
		(*diodepb.Manufacturer)(nil),
		(*diodepb.Platform)(nil),
		(*diodepb.Prefix)(nil),
		(*diodepb.Role)(nil),
		(*diodepb.Site)(nil),
		(*diodepb.Tag)(nil),
	}

	fmt.Print("// Code generated by github.com/diode-sdk-go/internal/cmd/codegen. DO NOT EDIT.\n\n")
	fmt.Print("package diode\n\n")
	fmt.Print("import (\n")
	fmt.Print("\t\"google.golang.org/protobuf/proto\"\n")
	fmt.Print("\n")
	fmt.Print("\t\"github.com/netboxlabs/diode-sdk-go/diode/v1/diodepb\"\n")
	fmt.Print(")\n\n")

	fmt.Printf("// Entity is an interface that all entities must implement\n")
	fmt.Printf("type Entity interface {\n")
	fmt.Printf("\tConvertToProtoMessage() proto.Message\n")
	fmt.Printf("\tConvertToProtoEntity() *diodepb.Entity\n")
	fmt.Printf("}\n\n")

	for _, t := range protoTypes {
		entityType := assignableEntityTypes[string(t.ProtoReflect().Type().Descriptor().Name())]
		GenerateDiodeSDKStruct(t, entityType)
	}
}

// GenerateDiodeSDKStruct generates a struct based on the given proto message
func GenerateDiodeSDKStruct(pm protoreflect.ProtoMessage, ae assignableEntity) {
	t := reflect.TypeOf(pm).Elem()
	protoFields := pm.ProtoReflect().Descriptor().Fields()

	fmt.Printf("// %s is based on diodepb.%s\n", t.Name(), t.Name())
	fmt.Printf("type %s struct {\n", t.Name())
	var currentExportedFieldIdx int
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.IsExported() {
			protoField := protoFields.Get(currentExportedFieldIdx)
			if protoField == nil {
				panic(fmt.Sprintf("protoField is nil for %s", field.Name))
			}

			fieldTypeStr := strings.TrimPrefix(field.Type.String(), "*")

			if protoField.Kind() == protoreflect.MessageKind {
				fieldTypeParts := strings.Split(fieldTypeStr, ".")
				fieldTypeStr = fieldTypeParts[len(fieldTypeParts)-1]

				if field.Tag.Get("protobuf_oneof") != "" {
					fieldTypeStr = string(protoField.Message().FullName().Name())
				}

				fieldTypeStr = "*" + fieldTypeStr

				if protoField.Cardinality() == protoreflect.Repeated {
					fieldTypeStr = "[]" + fieldTypeStr
				}
			} else {
				fieldTypeStr = "*" + fieldTypeStr
			}

			fmt.Printf("\t%s %s\n", field.Name, fieldTypeStr)
			currentExportedFieldIdx++
		}
	}
	fmt.Printf("}\n\n")

	methodsToGenerate := make([]methodParams, 0)

	fmt.Printf("// ConvertToProtoMessage%s converts a %s to a diodepb.%s\n", t.Name(), t.Name(), t.Name())
	fmt.Printf("func (e *%s) ConvertToProtoMessage() proto.Message {\n", t.Name())
	fmt.Printf("\treturn &diodepb.%s{\n", t.Name())
	currentExportedFieldIdx = 0
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.IsExported() {
			protoField := protoFields.Get(currentExportedFieldIdx)
			if protoField == nil {
				panic(fmt.Sprintf("protoField is nil for %s", field.Name))
			}

			fieldType := field.Type.Kind()

			if protoField.Kind() == protoreflect.MessageKind {
				mp := methodParams{
					fieldName:    field.Name,
					pointer:      true,
					messageField: true,
				}
				if protoField.Cardinality() != protoreflect.Repeated {
					if ae.nestedAssignableEntities != nil {
						mp.nestedFieldName = ae.nestedAssignableEntities[field.Name].fieldName
						mp.nestedMessageName = ae.nestedAssignableEntities[field.Name].messageName
					} else {
						mp.fieldType = field.Type.Elem().Name()
					}
				} else {
					mp.repeated = true
					mp.repeatedFieldType = string(protoField.Message().Name())
				}
				methodsToGenerate = append(methodsToGenerate, mp)

				fmt.Printf("\t\t%s: e.Get%s(),\n", field.Name, field.Name)
			} else if fieldType == reflect.Ptr {
				fmt.Printf("\t\t%s: e.Get%s(),\n", field.Name, field.Name)

				methodsToGenerate = append(methodsToGenerate, methodParams{
					fieldName: field.Name,
					fieldType: field.Type.Elem().Name(),
					pointer:   true,
				})
			} else {
				mp := methodParams{
					fieldName: field.Name,
					pointer:   false,
				}
				if fieldType == reflect.String {
					mp.fieldType = "string"
				} else if fieldType == reflect.Bool {
					mp.fieldType = "bool"
				} else if fieldType == reflect.Int32 {
					mp.fieldType = "int32"
				} else {
					panic(fmt.Sprintf("unsupported field type %s for %s", fieldType, field.Name))
				}
				fmt.Printf("\t\t%s: e.Get%s(),\n", field.Name, field.Name)

				methodsToGenerate = append(methodsToGenerate, mp)
			}
			currentExportedFieldIdx++
		}
	}

	fmt.Printf("\t}\n")
	fmt.Printf("}\n\n")

	for _, mp := range methodsToGenerate {
		generateGetterMethod(t, mp)
	}

	if ae.fieldName == "" {
		return
	}

	fmt.Printf("// ConvertToProtoEntity%s converts a %s to a diodepb.Entity\n", t.Name(), t.Name())
	fmt.Printf("func (e *%s) ConvertToProtoEntity() *diodepb.Entity {\n", t.Name())
	fmt.Print("\treturn &diodepb.Entity{\n")
	fmt.Printf("\t\tEntity: &diodepb.Entity_%s{\n", ae.fieldName)
	fmt.Printf("\t\t\t%s: e.ConvertToProtoMessage().(*diodepb.%s),\n", ae.fieldName, t.Name())
	fmt.Print("\t\t},\n")
	fmt.Print("\t}\n")
	fmt.Printf("}\n\n")
}

// retrieveTypesAssignableToEntities returns a map of entity names to their corresponding proto message names
func retrieveTypesAssignableToEntities(m protoreflect.Message, parentFieldName string) map[string]assignableEntity {
	assignableEntityTypes := make(map[string]assignableEntity)

	if mi, ok := m.(interface{ ProtoMessageInfo() *protoimpl.MessageInfo }); ok {
		exportedFields := exportedProtoFields(mi.ProtoMessageInfo().GoReflectType.Elem())

		for _, wrapper := range mi.ProtoMessageInfo().OneofWrappers {
			t := reflect.TypeOf(wrapper).Elem()
			field := t.Field(0)
			if protoMsg, ok2 := reflect.New(field.Type.Elem()).Interface().(protoreflect.ProtoMessage); ok2 {
				ae := assignableEntity{
					fieldName:       field.Name,
					parentFieldName: parentFieldName,
					messageName:     t.Name(),
				}

				fieldName := string(protoMsg.ProtoReflect().Type().Descriptor().Name())
				if parentFieldName != "" {
					for i := 0; i < m.Type().Descriptor().Fields().Len(); i++ {
						f := m.Type().Descriptor().Fields().Get(i)

						if f.ContainingOneof() != nil && f.Kind() == protoreflect.MessageKind {
							fieldName = exportedFields[f.Index()].Name
						}
					}
				}

				nestedAssignableEntityTypes := retrieveTypesAssignableToEntities(protoMsg.ProtoReflect(), t.Name())

				if len(nestedAssignableEntityTypes) > 0 {
					ae.nestedAssignableEntities = nestedAssignableEntityTypes
				}

				assignableEntityTypes[fieldName] = ae

			} else {
				panic(fmt.Sprintf("not a proto message: %s", field.Type.Elem().Name()))
			}
		}
	}

	return assignableEntityTypes
}

func exportedProtoFields(t reflect.Type) []reflect.StructField {
	var fields []reflect.StructField
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.PkgPath == "" {
			fields = append(fields, field)
		}
	}
	return fields
}

func generateGetterMethod(t reflect.Type, params methodParams) {
	fmt.Printf("// Get%s returns the %s field\n", params.fieldName, params.fieldName)

	returnType := params.fieldType
	if params.messageField {
		returnType = "*diodepb." + params.fieldType
		if params.nestedFieldName != "" {
			returnType = "*diodepb." + params.nestedMessageName
		}
		if params.repeated {
			returnType = "[]*diodepb." + params.repeatedFieldType
		}
	} else if params.nestedFieldName != "" {
		returnType = "*diodepb." + params.nestedMessageName
	} else if params.pointer {
		returnType = "*" + params.fieldType
	}

	fmt.Printf("func (e *%s) Get%s() %s {\n", t.Name(), params.fieldName, returnType)
	if params.messageField {
		if !params.repeated {
			fmt.Printf("\tif e != nil && e.%s != nil {\n", params.fieldName)
			if params.nestedFieldName != "" {
				fmt.Printf("\t\treturn &diodepb.%s{\n", params.nestedMessageName)
				fmt.Printf("\t\t\t%s: e.%s.ConvertToProtoMessage().(*diodepb.%s),\n", params.nestedFieldName, params.fieldName, params.nestedFieldName)
				fmt.Printf("\t\t}\n")
			} else {
				fmt.Printf("\t\treturn e.%s.ConvertToProtoMessage().(*diodepb.%s)\n", params.fieldName, params.fieldType)
			}
			fmt.Printf("\t}\n")
			fmt.Printf("\treturn nil\n")
		} else {
			sliceVarName := strings.ToLower(params.fieldName)
			fmt.Printf("\tvar %s []*diodepb.%s\n", sliceVarName, params.repeatedFieldType)
			fmt.Printf("\tfor _, el := range e.%s {\n", params.fieldName)
			fmt.Printf("\t\t%s = append(%s, el.ConvertToProtoMessage().(*diodepb.%s))\n", sliceVarName, sliceVarName, params.repeatedFieldType)
			fmt.Printf("\t}\n")
			fmt.Printf("\treturn %s\n", sliceVarName)
		}
	} else if params.pointer {
		fmt.Printf("\tif e != nil && e.%s != nil {\n", params.fieldName)
		if params.nestedFieldName != "" {
			fmt.Printf("\t\treturn *diodepb.%s{\n", params.nestedFieldName)
			fmt.Printf("\t\t\t%s: e.%s.ConvertToProtoMessage().(*diodepb.%s),\n", params.nestedFieldName, params.fieldName, params.nestedFieldName)
			fmt.Printf("\t\t}\n")
		} else {
			fmt.Printf("\t\treturn e.%s\n", params.fieldName)
		}
		fmt.Printf("\t}\n")
		fmt.Printf("\treturn nil\n")
	} else {
		fmt.Printf("\tif e != nil && e.%s != nil {\n", params.fieldName)
		fmt.Printf("\t\treturn *e.%s\n", params.fieldName)
		fmt.Printf("\t}\n")
		fmt.Printf("\treturn \"\"\n")
	}
	fmt.Printf("}\n\n")
}
